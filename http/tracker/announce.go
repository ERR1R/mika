package tracker

import (
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"mika/http"
	"mika/model"
	"mika/util"
	"net"
	"strings"
)

type BitTorrentHandler struct{}

// Represents an announce received from the bittorrent client
//
// TODO use gin binding func?
type AnnounceRequest struct {
	Compact bool `binding:"required"` // Force compact always?

	// The total amount downloaded (since the client sent the 'started' event to the tracker) in
	// base ten ASCII. While not explicitly stated in the official specification, the consensus is that
	// this should be the total number of bytes downloaded.
	Downloaded uint64 `binding:"required"`

	// The number of bytes this peer still has to download, encoded in base ten ascii.
	// Note that this can't be computed from downloaded and the file length since it
	// might be a resume, and there's a chance that some of the downloaded data failed an
	// integrity check and had to be re-downloaded.
	Left uint64 `binding:"required"`

	// The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten
	// ASCII. While not explicitly stated in the official specification, the concensus is that this should
	// be the total number of bytes uploaded.
	Uploaded uint64 `binding:"required"`

	Corrupt uint64
	// This is an optional key which maps to started, completed, or stopped (or empty,
	// which is the same as not being present). If not present, this is one of the
	// announcements done at regular intervals. An announcement using started is sent
	// when a download first begins, and one using completed is sent when the download
	// is complete. No completed is sent if the file was complete when started. Downloaders
	// send an announcement using stopped when they cease downloading.
	Event http.AnnounceType

	//  Optional. The true IP address of the client machine, in dotted quad format or rfc3513
	// defined hexed IPv6 address. Notes: In general this parameter is not necessary as the address
	// of the client can be determined from the IP address from which the HTTP request came.
	// The parameter is only needed in the case where the IP address that the request came in on
	// is not the IP address of the client. This happens if the client is communicating to the
	// tracker through a proxy (or a transparent web proxy/cache.) It also is necessary when both the
	// client and the tracker are on the same local side of a NAT gateway. The reason for this is that
	// otherwise the tracker would give out the internal (RFC1918) address of the client, which is not
	// routable. Therefore the client must explicitly state its (external, routable) IP address to be
	// given out to external peers. Various trackers treat this parameter differently. Some only honor
	// it only if the IP address that the request came in on is in RFC1918 space. Others honor it
	// unconditionally, while others ignore it completely. In case of IPv6 address (e.g.: 2001:db8:1:2::100)
	// it indicates only that client can communicate via IPv6.
	IP net.IP `form:"ip" binding:"required"`

	// urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. Note that the
	// value will be a bencoded dictionary, given the definition of the info key above.
	InfoHash model.InfoHash `form:"ip"`

	// Optional. Number of peers that the client would like to receive from the tracker. This value is
	// permitted to be zero. If omitted, typically defaults to 50 peers.
	NumWant int

	// Required for private tracker use. Authentication key to authenticate requests
	Passkey string

	// urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	// This is allowed to be any value, and may be binary data. There are currently no guidelines for
	// generating this peer ID. However, one may rightly presume that it must at least be unique for
	// your local machine, thus should probably incorporate things like process ID and perhaps a timestamp
	// recorded at startup. See peer_id below for common client encodings of this field.
	PeerID []byte

	// The port number that the client is listening on. Ports reserved for BitTorrent are typically
	// 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
	Port uint64 `binding:"required"`

	// Optional. If a previous announce contained a tracker id, it should be set here.
	TrackerId string
}

type AnnounceResponse struct {
	//  (optional) Minimum announce interval. If present clients must not reannounce more frequently than this.
	MinInterval int `bencode:"min interval"`

	Complete int `bencode:"complete"`

	Incomplete int `bencode:"incomplete"`
	// Interval in seconds that the client should wait between sending regular requests to the tracker
	Interval int    `bencode:"interval"`
	Peers    string `bencode:"peers"`
	//  A string that the client should send back on its next announcements. If absent and a previous
	//  announce sent a tracker id, do not discard the old value; keep using it.
	TrackerId []byte
	// ( optional ) Similar to failure reason, but the response still gets processed normally. The warning message is
	// shown just like an error.
	Warning string `bencode:"warning message"`
}

// Parse the query string into an AnnounceRequest struct
func NewAnnounce(c *gin.Context) (*AnnounceRequest, http.TrackerErrCode) {
	q, err := QueryStringParser(c.Request.RequestURI)
	if err != nil {
		return nil, err
	}

	compact := q.Params["compact"] != "0"

	event := http.ANNOUNCE
	event_name, _ := q.Params["event"]
	switch event_name {
	case "started":
		event = http.STARTED
	case "stopped":
		event = http.STOPPED
	case "completed":
		event = http.COMPLETED
	}

	numWant := getNumWant(q, 30)

	info_hash, exists := q.Params["info_hash"]
	if !exists {
		return nil, http.MsgInvalidInfoHash
	}

	peerID, exists := q.Params["peer_id"]
	if !exists {
		return nil, http.MsgInvalidPeerId
	}

	ipv4, err := getIP(q.Params["ip"])
	if err != nil {
		// Look for forwarded ip in header then default to remote address
		forwarded_ip := c.Request.Header.Get("X-Forwarded-For")
		if forwarded_ip != "" {
			ipv4_new, err := getIP(forwarded_ip)
			if err != nil {
				log.Error("NewAnnounce: Failed to parse header supplied IP", err)
				return nil, errors.New("Invalid ip header")
			}
			ipv4 = ipv4_new
		} else {
			s := strings.Split(c.Request.RemoteAddr, ":")
			ip_req, _ := s[0], s[1]
			ipv4_new, err := getIP(ip_req)
			if err != nil {
				log.Error("NewAnnounce: Failed to parse detected IP", err)
				return nil, errors.New("Invalid ip hash")
			}
			ipv4 = ipv4_new
		}
	}

	port, err := q.Uint64("port")
	if err != nil || port < 1024 || port > 65535 {
		return nil, errors.New("Invalid port, must be between 1024 and 65535")
	}

	left, err := q.Uint64("left")
	if err != nil {
		return nil, errors.New("No left value")
	} else {
		left = util.UMax(0, left)
	}

	downloaded, err := q.Uint64("downloaded")
	if err != nil {
		downloaded = 0
	} else {
		downloaded = util.UMax(0, downloaded)
	}

	uploaded, err := q.Uint64("uploaded")
	if err != nil {
		uploaded = 0
	} else {
		uploaded = util.UMax(0, uploaded)
	}

	corrupt, err := q.Uint64("corrupt")
	if err != nil {
		// Assume we just don't have the param
		corrupt = 0
	} else {
		corrupt = util.UMax(0, corrupt)
	}

	return &AnnounceRequest{
		Compact:    compact,
		Corrupt:    corrupt,
		Downloaded: downloaded,
		Event:      event,
		IP:         ipv4,
		InfoHash:   info_hash,
		Left:       left,
		NumWant:    numWant,
		PeerID:     peerID,
		Port:       port,
		Uploaded:   uploaded,
	}, nil
}

func (h *BitTorrentHandler) Announce(c *gin.Context) {
	var req AnnounceRequest
	if err := c.Bind(&req); err != nil {
		c.String(http.MsgMalformedRequest, "Error: %s", err.Error())
		return
	}

}
