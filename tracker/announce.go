package tracker

import (
	"bytes"
	"github.com/chihaya/bencode"
	"github.com/gin-gonic/gin"
	"github.com/leighmacdonald/mika/consts"
	"github.com/leighmacdonald/mika/model"
	"github.com/leighmacdonald/mika/util"
	log "github.com/sirupsen/logrus"
	"net"
	"strings"
	"time"
)

// BitTorrentHandler is the public HTTP interface for the tracker handling announces and
// scrape requests
type BitTorrentHandler struct {
	tracker *Tracker
}

// Represents an announce received from the bittorrent client
//
// TODO use gin binding func?
type announceRequest struct {
	Compact bool // Force compact always?

	// The total amount downloaded (since the client sent the 'started' event to the tracker) in
	// base ten ASCII. While not explicitly stated in the official specification, the consensus is that
	// this should be the total number of bytes downloaded.
	Downloaded uint32

	// The number of bytes this peer still has to download, encoded in base ten ascii.
	// Note that this can'tracker be computed from downloaded and the file length since it
	// might be a resume, and there's a chance that some of the downloaded data failed an
	// integrity check and had to be re-downloaded.
	Left uint32

	// The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten
	// ASCII. While not explicitly stated in the official specification, the consensus is that this should
	// be the total number of bytes uploaded.
	Uploaded uint32

	Corrupt uint32

	// This is an optional key which maps to started, completed, or stopped (or empty,
	// which is the same as not being present). If not present, this is one of the
	// announcements done at regular intervals. An announcement using started is sent
	// when a download first begins, and one using completed is sent when the download
	// is complete. No completed is sent if the file was complete when started. Downloaders
	// send an announcement using stopped when they cease downloading.
	Event consts.AnnounceType

	//  Optional. The true IP address of the client machine, in dotted quad format or rfc3513
	// defined hexed IPv6 address. Notes: In general this parameter is not necessary as the address
	// of the client can be determined from the IP address from which the HTTP request came.
	// The parameter is only needed in the case where the IP address that the request came in on
	// is not the IP address of the client. This happens if the client is communicating to the
	// tracker through a proxy (or a transparent web proxy/cache.) It also is necessary when both the
	// client and the tracker are on the same local side of a NAT gateway. The reason for this is that
	// otherwise the tracker would give out the internal (RFC1918) address of the client, which is not
	// routable. Therefore the client must explicitly state its (external, routable) IP address to be
	// given out to external peers. Various trackers treat this parameter differently. Some only honor
	// it only if the IP address that the request came in on is in RFC1918 space. Others honor it
	// unconditionally, while others ignore it completely. In case of IPv6 address (e.g.: 2001:db8:1:2::100)
	// it indicates only that client can communicate via IPv6.
	IP net.IP

	// urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. Note that the
	// value will be a bencoded dictionary, given the definition of the info key above.
	InfoHash model.InfoHash

	// Optional. Number of peers that the client would like to receive from the tracker. This value is
	// permitted to be zero. If omitted, typically defaults to 50 peers.
	NumWant uint

	// Required for private tracker use. Authentication key to authenticate requests
	Passkey string

	// urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	// This is allowed to be any value, and may be binary data. There are currently no guidelines for
	// generating this peer ID. However, one may rightly presume that it must at least be unique for
	// your local machine, thus should probably incorporate things like process ID and perhaps a timestamp
	// recorded at startup. See peer_id below for common client encodings of this field.
	PeerID model.PeerID

	// The port number that the client is listening on. Ports reserved for BitTorrent are typically
	// 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
	Port uint16

	// Optional. If a previous announce contained a tracker id, it should be set here.
	TrackerID string
}

// Parse the query string into an announceRequest struct
func (h *BitTorrentHandler) newAnnounce(c *gin.Context) (*announceRequest, errCode) {
	q, err := queryStringParser(c.Request.URL.RawQuery)
	if err != nil {
		return nil, msgMalformedRequest
	}
	infoHashStr, ihExists := q.Params[paramInfoHash]
	if !ihExists {
		return nil, msgInvalidInfoHash
	}
	var infoHash model.InfoHash
	if err := model.InfoHashFromString(&infoHash, infoHashStr); err != nil {
		log.Warnf("Got malformed info_hash: %s", infoHashStr)
		return nil, msgInvalidInfoHash
	}
	peerID, exists := q.Params[paramPeerID]
	if !exists {
		return nil, msgInvalidPeerID
	}
	ipAddr, err2 := getIP(q, c)
	if err2 != nil {
		log.Warn("Could not get user IP from request")
		return nil, msgMalformedRequest
	}
	if strings.Contains(ipAddr.String(), ":") {
		log.Warn("Got ipv6 peer request")
		return nil, msgMalformedRequest
	}
	if !h.tracker.AllowNonRoutable && util.IsPrivateIP(ipAddr) {
		log.Warnf("Attempt to use non-routable IP value: %s", ipAddr.String())
		return nil, msgGenericError
	}
	port := getUint16Key(q, paramPort, 0)
	if port < 1024 {
		// Don't allow privileged ports which require root to bind to on unix
		return nil, msgInvalidPort
	}
	left := getUint32Key(q, paramLeft, 0)
	downloaded := getUint32Key(q, paramDownloaded, 0)
	uploaded := getUint32Key(q, paramUploaded, 0)
	corrupt := getUint32Key(q, paramCorrupt, 0)
	event := consts.ParseAnnounceType(q.Params[paramEvent])
	numWant := getUintKey(q, paramNumWant, 30)
	return &announceRequest{
		Compact:    true, // Ignored and always set to true
		Corrupt:    corrupt,
		Downloaded: downloaded,
		Event:      event,
		IP:         ipAddr,
		InfoHash:   infoHash,
		Left:       left,
		NumWant:    numWant,
		PeerID:     model.PeerIDFromString(peerID),
		Port:       port,
		Uploaded:   uploaded,
	}, msgOk
}

// The meaty bits.
// NOTE we ONLY support compact response formats (binary format) by design even though its
// technically breaking the protocol specs.
// There is no reason to support the older less efficient model for private needs
func (h *BitTorrentHandler) announce(c *gin.Context) {
	// Check that the user is valid before parsing anything
	pk := c.Param("passkey")
	var usr model.User
	if valid := preFlightChecks(&usr, pk, c, h.tracker); !valid {
		oops(c, msgInvalidAuth)
		return
	}
	// Parse the announce into an announceRequest
	req, code := h.newAnnounce(c)
	if code != msgOk {
		oops(c, code)
		return
	}
	// Get & Validate the torrent associated with the info_hash supplies
	var tor model.Torrent
	if err := h.tracker.Torrents.Get(&tor, req.InfoHash, false); err != nil || tor.IsDeleted {
		log.Debugf("No torrent found matching: %x", req.InfoHash.Bytes())
		oops(c, msgInvalidInfoHash)
		return
	}
	// If disabled and reason is set, the reason is returned to the client
	// This is mostly useful for when a torrent has been "trumped" by another torrent so it
	// should be downloaded instead
	//
	// TODO send this as a "warning message" field of a normal announce response instead?
	if !tor.IsEnabled && tor.Reason != "" {
		log.Debugf("Torrent found but is disabled: %x", req.InfoHash.Bytes())
		c.Data(int(msgInvalidInfoHash), gin.MIMEPlain, responseError(tor.Reason))
		return
	}
	var peer model.Peer
	err := h.tracker.Peers.Get(&peer, tor.InfoHash, req.PeerID)
	if err != nil {
		if err == consts.ErrInvalidPeerID {
			// Create a new peer for the swarm
			peer = model.NewPeer(usr.UserID, req.PeerID, req.IP, req.Port)
			if err := h.tracker.Peers.Add(tor.InfoHash, peer); err != nil {
				log.Errorf("Failed to insert peer into swarm: %s", err.Error())
				oops(c, msgGenericError)
				return
			}
			if h.tracker.GeodbEnabled {
				peer.Location = h.tracker.Geodb.GetLocation(peer.IP).Location
			}
		} else {
			oops(c, msgGenericError)
			return
		}
	} else {
		peer.AnnounceLast = time.Now()
	}
	// Send state to another go channel for updating outside of the announce request
	// so that we can respond asap
	h.tracker.StateUpdateChan <- model.UpdateState{
		Passkey:    pk,
		InfoHash:   tor.InfoHash,
		PeerID:     peer.PeerID,
		Uploaded:   uint64(req.Uploaded),
		Downloaded: uint64(req.Downloaded),
		Left:       req.Left,
		Event:      req.Event,
		Timestamp:  time.Now(),
		Paused:     peer.Paused,
	}
	peers, err2 := h.tracker.Peers.GetN(tor.InfoHash, h.tracker.MaxPeers)
	if err2 != nil {
		log.Errorf("Could not read peers from swarm: %s", err2.Error())
		oops(c, msgGenericError)
		return
	}
	dict := bencode.Dict{
		"complete":     tor.Seeders,
		"incomplete":   tor.Leechers,
		"interval":     int(h.tracker.AnnInterval.Seconds()),
		"min interval": int(h.tracker.AnnIntervalMin.Seconds()),
		"peers":        makeCompactPeers(peers, peer.PeerID),
	}
	var outBytes bytes.Buffer
	if err := bencode.NewEncoder(&outBytes).Encode(dict); err != nil {
		oops(c, msgGenericError)
		return
	}
	c.Data(int(msgOk), gin.MIMEPlain, outBytes.Bytes())
}

// Generate a compact peer field array containing the byte representations
// of a peers IP+Port appended to each other
func makeCompactPeers(peers model.Swarm, skipID model.PeerID) []byte {
	var buf bytes.Buffer
	peers.RLock()
	for _, peer := range peers.Peers {
		if peer.PeerID == skipID {
			// Skip the peers own peer_id
			continue
		}
		buf.Write(peer.IP.To4())
		buf.Write([]byte{byte(peer.Port >> 8), byte(peer.Port & 0xff)})
	}
	peers.RUnlock()
	return buf.Bytes()
}
