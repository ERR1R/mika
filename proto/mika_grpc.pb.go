// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MikaClient is the client API for Mika service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MikaClient interface {
	ConfigUpdate(ctx context.Context, in *ConfigUpdateParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WhiteListAdd(ctx context.Context, in *WhiteListParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WhiteListDelete(ctx context.Context, in *WhiteListDeleteParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WhiteList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WhiteListResponse, error)
	TorrentGet(ctx context.Context, in *TorrentParams, opts ...grpc.CallOption) (*Torrent, error)
	TorrentAdd(ctx context.Context, in *TorrentAddParams, opts ...grpc.CallOption) (*Torrent, error)
	TorrentDelete(ctx context.Context, in *InfoHashParam, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TorrentUpdate(ctx context.Context, in *TorrentUpdateParams, opts ...grpc.CallOption) (*Torrent, error)
	UserGet(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*User, error)
	UserAll(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Mika_UserAllClient, error)
	UserSave(ctx context.Context, in *UserUpdateParams, opts ...grpc.CallOption) (*User, error)
	UserDelete(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UserAdd(ctx context.Context, in *UserAddParams, opts ...grpc.CallOption) (*User, error)
	RoleAll(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Mika_RoleAllClient, error)
	RoleAdd(ctx context.Context, in *RoleAddParams, opts ...grpc.CallOption) (*Role, error)
	RoleDelete(ctx context.Context, in *RoleID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RoleSave(ctx context.Context, in *Role, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mikaClient struct {
	cc grpc.ClientConnInterface
}

func NewMikaClient(cc grpc.ClientConnInterface) MikaClient {
	return &mikaClient{cc}
}

func (c *mikaClient) ConfigUpdate(ctx context.Context, in *ConfigUpdateParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/ConfigUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) WhiteListAdd(ctx context.Context, in *WhiteListParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/WhiteListAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) WhiteListDelete(ctx context.Context, in *WhiteListDeleteParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/WhiteListDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) WhiteList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WhiteListResponse, error) {
	out := new(WhiteListResponse)
	err := c.cc.Invoke(ctx, "/mika.Mika/WhiteList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) TorrentGet(ctx context.Context, in *TorrentParams, opts ...grpc.CallOption) (*Torrent, error) {
	out := new(Torrent)
	err := c.cc.Invoke(ctx, "/mika.Mika/TorrentGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) TorrentAdd(ctx context.Context, in *TorrentAddParams, opts ...grpc.CallOption) (*Torrent, error) {
	out := new(Torrent)
	err := c.cc.Invoke(ctx, "/mika.Mika/TorrentAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) TorrentDelete(ctx context.Context, in *InfoHashParam, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/TorrentDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) TorrentUpdate(ctx context.Context, in *TorrentUpdateParams, opts ...grpc.CallOption) (*Torrent, error) {
	out := new(Torrent)
	err := c.cc.Invoke(ctx, "/mika.Mika/TorrentUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) UserGet(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/mika.Mika/UserGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) UserAll(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Mika_UserAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &Mika_ServiceDesc.Streams[0], "/mika.Mika/UserAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &mikaUserAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Mika_UserAllClient interface {
	Recv() (*User, error)
	grpc.ClientStream
}

type mikaUserAllClient struct {
	grpc.ClientStream
}

func (x *mikaUserAllClient) Recv() (*User, error) {
	m := new(User)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mikaClient) UserSave(ctx context.Context, in *UserUpdateParams, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/mika.Mika/UserSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) UserDelete(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/UserDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) UserAdd(ctx context.Context, in *UserAddParams, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/mika.Mika/UserAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) RoleAll(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Mika_RoleAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &Mika_ServiceDesc.Streams[1], "/mika.Mika/RoleAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &mikaRoleAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Mika_RoleAllClient interface {
	Recv() (*Role, error)
	grpc.ClientStream
}

type mikaRoleAllClient struct {
	grpc.ClientStream
}

func (x *mikaRoleAllClient) Recv() (*Role, error) {
	m := new(Role)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mikaClient) RoleAdd(ctx context.Context, in *RoleAddParams, opts ...grpc.CallOption) (*Role, error) {
	out := new(Role)
	err := c.cc.Invoke(ctx, "/mika.Mika/RoleAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) RoleDelete(ctx context.Context, in *RoleID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/RoleDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mikaClient) RoleSave(ctx context.Context, in *Role, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/mika.Mika/RoleSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MikaServer is the server API for Mika service.
// All implementations must embed UnimplementedMikaServer
// for forward compatibility
type MikaServer interface {
	ConfigUpdate(context.Context, *ConfigUpdateParams) (*emptypb.Empty, error)
	WhiteListAdd(context.Context, *WhiteListParams) (*emptypb.Empty, error)
	WhiteListDelete(context.Context, *WhiteListDeleteParams) (*emptypb.Empty, error)
	WhiteList(context.Context, *emptypb.Empty) (*WhiteListResponse, error)
	TorrentGet(context.Context, *TorrentParams) (*Torrent, error)
	TorrentAdd(context.Context, *TorrentAddParams) (*Torrent, error)
	TorrentDelete(context.Context, *InfoHashParam) (*emptypb.Empty, error)
	TorrentUpdate(context.Context, *TorrentUpdateParams) (*Torrent, error)
	UserGet(context.Context, *UserID) (*User, error)
	UserAll(*emptypb.Empty, Mika_UserAllServer) error
	UserSave(context.Context, *UserUpdateParams) (*User, error)
	UserDelete(context.Context, *UserID) (*emptypb.Empty, error)
	UserAdd(context.Context, *UserAddParams) (*User, error)
	RoleAll(*emptypb.Empty, Mika_RoleAllServer) error
	RoleAdd(context.Context, *RoleAddParams) (*Role, error)
	RoleDelete(context.Context, *RoleID) (*emptypb.Empty, error)
	RoleSave(context.Context, *Role) (*emptypb.Empty, error)
	mustEmbedUnimplementedMikaServer()
}

// UnimplementedMikaServer must be embedded to have forward compatible implementations.
type UnimplementedMikaServer struct {
}

func (UnimplementedMikaServer) ConfigUpdate(context.Context, *ConfigUpdateParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdate not implemented")
}
func (UnimplementedMikaServer) WhiteListAdd(context.Context, *WhiteListParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WhiteListAdd not implemented")
}
func (UnimplementedMikaServer) WhiteListDelete(context.Context, *WhiteListDeleteParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WhiteListDelete not implemented")
}
func (UnimplementedMikaServer) WhiteList(context.Context, *emptypb.Empty) (*WhiteListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WhiteList not implemented")
}
func (UnimplementedMikaServer) TorrentGet(context.Context, *TorrentParams) (*Torrent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TorrentGet not implemented")
}
func (UnimplementedMikaServer) TorrentAdd(context.Context, *TorrentAddParams) (*Torrent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TorrentAdd not implemented")
}
func (UnimplementedMikaServer) TorrentDelete(context.Context, *InfoHashParam) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TorrentDelete not implemented")
}
func (UnimplementedMikaServer) TorrentUpdate(context.Context, *TorrentUpdateParams) (*Torrent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TorrentUpdate not implemented")
}
func (UnimplementedMikaServer) UserGet(context.Context, *UserID) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGet not implemented")
}
func (UnimplementedMikaServer) UserAll(*emptypb.Empty, Mika_UserAllServer) error {
	return status.Errorf(codes.Unimplemented, "method UserAll not implemented")
}
func (UnimplementedMikaServer) UserSave(context.Context, *UserUpdateParams) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSave not implemented")
}
func (UnimplementedMikaServer) UserDelete(context.Context, *UserID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDelete not implemented")
}
func (UnimplementedMikaServer) UserAdd(context.Context, *UserAddParams) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAdd not implemented")
}
func (UnimplementedMikaServer) RoleAll(*emptypb.Empty, Mika_RoleAllServer) error {
	return status.Errorf(codes.Unimplemented, "method RoleAll not implemented")
}
func (UnimplementedMikaServer) RoleAdd(context.Context, *RoleAddParams) (*Role, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAdd not implemented")
}
func (UnimplementedMikaServer) RoleDelete(context.Context, *RoleID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleDelete not implemented")
}
func (UnimplementedMikaServer) RoleSave(context.Context, *Role) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleSave not implemented")
}
func (UnimplementedMikaServer) mustEmbedUnimplementedMikaServer() {}

// UnsafeMikaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MikaServer will
// result in compilation errors.
type UnsafeMikaServer interface {
	mustEmbedUnimplementedMikaServer()
}

func RegisterMikaServer(s grpc.ServiceRegistrar, srv MikaServer) {
	s.RegisterService(&Mika_ServiceDesc, srv)
}

func _Mika_ConfigUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).ConfigUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/ConfigUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).ConfigUpdate(ctx, req.(*ConfigUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_WhiteListAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhiteListParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).WhiteListAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/WhiteListAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).WhiteListAdd(ctx, req.(*WhiteListParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_WhiteListDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhiteListDeleteParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).WhiteListDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/WhiteListDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).WhiteListDelete(ctx, req.(*WhiteListDeleteParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_WhiteList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).WhiteList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/WhiteList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).WhiteList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_TorrentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TorrentParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).TorrentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/TorrentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).TorrentGet(ctx, req.(*TorrentParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_TorrentAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TorrentAddParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).TorrentAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/TorrentAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).TorrentAdd(ctx, req.(*TorrentAddParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_TorrentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoHashParam)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).TorrentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/TorrentDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).TorrentDelete(ctx, req.(*InfoHashParam))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_TorrentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TorrentUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).TorrentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/TorrentUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).TorrentUpdate(ctx, req.(*TorrentUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_UserGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).UserGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/UserGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).UserGet(ctx, req.(*UserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_UserAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MikaServer).UserAll(m, &mikaUserAllServer{stream})
}

type Mika_UserAllServer interface {
	Send(*User) error
	grpc.ServerStream
}

type mikaUserAllServer struct {
	grpc.ServerStream
}

func (x *mikaUserAllServer) Send(m *User) error {
	return x.ServerStream.SendMsg(m)
}

func _Mika_UserSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).UserSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/UserSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).UserSave(ctx, req.(*UserUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_UserDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).UserDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/UserDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).UserDelete(ctx, req.(*UserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_UserAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAddParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).UserAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/UserAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).UserAdd(ctx, req.(*UserAddParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_RoleAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MikaServer).RoleAll(m, &mikaRoleAllServer{stream})
}

type Mika_RoleAllServer interface {
	Send(*Role) error
	grpc.ServerStream
}

type mikaRoleAllServer struct {
	grpc.ServerStream
}

func (x *mikaRoleAllServer) Send(m *Role) error {
	return x.ServerStream.SendMsg(m)
}

func _Mika_RoleAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAddParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).RoleAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/RoleAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).RoleAdd(ctx, req.(*RoleAddParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_RoleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).RoleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/RoleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).RoleDelete(ctx, req.(*RoleID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mika_RoleSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Role)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MikaServer).RoleSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mika.Mika/RoleSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MikaServer).RoleSave(ctx, req.(*Role))
	}
	return interceptor(ctx, in, info, handler)
}

// Mika_ServiceDesc is the grpc.ServiceDesc for Mika service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mika_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mika.Mika",
	HandlerType: (*MikaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigUpdate",
			Handler:    _Mika_ConfigUpdate_Handler,
		},
		{
			MethodName: "WhiteListAdd",
			Handler:    _Mika_WhiteListAdd_Handler,
		},
		{
			MethodName: "WhiteListDelete",
			Handler:    _Mika_WhiteListDelete_Handler,
		},
		{
			MethodName: "WhiteList",
			Handler:    _Mika_WhiteList_Handler,
		},
		{
			MethodName: "TorrentGet",
			Handler:    _Mika_TorrentGet_Handler,
		},
		{
			MethodName: "TorrentAdd",
			Handler:    _Mika_TorrentAdd_Handler,
		},
		{
			MethodName: "TorrentDelete",
			Handler:    _Mika_TorrentDelete_Handler,
		},
		{
			MethodName: "TorrentUpdate",
			Handler:    _Mika_TorrentUpdate_Handler,
		},
		{
			MethodName: "UserGet",
			Handler:    _Mika_UserGet_Handler,
		},
		{
			MethodName: "UserSave",
			Handler:    _Mika_UserSave_Handler,
		},
		{
			MethodName: "UserDelete",
			Handler:    _Mika_UserDelete_Handler,
		},
		{
			MethodName: "UserAdd",
			Handler:    _Mika_UserAdd_Handler,
		},
		{
			MethodName: "RoleAdd",
			Handler:    _Mika_RoleAdd_Handler,
		},
		{
			MethodName: "RoleDelete",
			Handler:    _Mika_RoleDelete_Handler,
		},
		{
			MethodName: "RoleSave",
			Handler:    _Mika_RoleSave_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UserAll",
			Handler:       _Mika_UserAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RoleAll",
			Handler:       _Mika_RoleAll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/mika.proto",
}
